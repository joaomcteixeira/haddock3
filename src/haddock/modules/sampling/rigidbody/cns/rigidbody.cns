! refine.inp
!    The core docking script of HADDOCK performing rigid-body docking
!    and semi-flexible refinement in torsion angle space
!
! ***********************************************************************
! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           *
! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************
!

!@RUN:initialize.cns(iteration=$iteration;)
!
!@NEWIT:iteration.cns(iteration=$iteration;)
!
!@RUN:run.cns(
!iteration =$iteration;
!filenames =$filenames;
!Data      =$Data;
!iterations=$iterations;
!saprotocol=$saprotocol;
!refine    =$refine;
!toppar    =$toppar;
!analysis  =$analysis;)

!evaluate ($log_level=quiet)
!evaluate ($log_level=verbose)
eval ($prot_segid_1="A")
eval ($prot_segid_2="B")
eval ($fix_origin_1=false)
eval ($fix_origin_2=false)
!eval ($toppar.shape_1=false)
!eval ($toppar.shape_2=false)
!eval ($toppar.dna_1=false)
!eval ($toppar.dna_2=false)
eval ($iteration = 0)

noe
  reset
  nrestraints = 12000000     ! allocate space for NOEs
  ceiling 1000
end

!==================================================================!


evaluate ($saprotocol.crossdock=$crossdock)
evaluate ($saprotocol.randorien=$randorien)
evaluate ($saprotocol.rebuildcplx=$rebuildcplx)
evaluate ($saprotocol.rigidmini=$rigidmini)
evaluate ($saprotocol.rigidtrans=$rigidtrans)
evaluate ($saprotocol.expand=$expand)
evaluate ($saprotocol.expansion=$expansion)
evaluate ($saprotocol.randangle=$randangle)

if ($saprotocol.expand eq true) then
  evaluate ($saprotocol.randorien = false)
  evaluate ($saprotocol.rigidmini = false)
end if

evaluate ($saprotocol.ntrials=$ntrials)
evaluate ($saprotocol.iniseed=$iniseed)
evaluate ($saprotocol.tadhigh_t=$tadhigh_t)
evaluate ($saprotocol.t1_init=$tadinit1_t)
evaluate ($saprotocol.t2_init=$tadinit2_t)
evaluate ($saprotocol.t3_init=$tadinit3_t)
evaluate ($saprotocol.t1_final=$tadfinal1_t)
evaluate ($saprotocol.t2_final=$tadfinal2_t)
evaluate ($saprotocol.t3_final=$tadfinal3_t)
evaluate ($saprotocol.inter_rigid=$inter_rigid)
evaluate ($saprotocol.inter_init_rigid=$init_rigid)
evaluate ($saprotocol.inter_fin_rigid=$fin_rigid)
evaluate ($saprotocol.inter_init_cool2=$init_cool2)
evaluate ($saprotocol.inter_fin_cool2=$fin_cool2)
evaluate ($saprotocol.inter_init_cool3=$init_cool3)
evaluate ($saprotocol.inter_fin_cool3=$fin_cool3)
evaluate ($saprotocol.rotate180_it0=$rotate180_it0)
evaluate ($saprotocol.rotate180_it1=$rotate180_it1)
evaluate ($saprotocol.tempstep=50)
evaluate ($saprotocol.timestep=$timestep)
evaluate ($saprotocol.tadfactor=$tadfactor)
evaluate ($saprotocol.emstepstrans=$emstepstrans)
evaluate ($saprotocol.initiosteps=$initiosteps)
evaluate ($saprotocol.cool1_steps=$cool1_steps)
evaluate ($saprotocol.cool2_steps=$cool2_steps)
evaluate ($saprotocol.cool3_steps=$cool3_steps)
evaluate ($saprotocol.fbeta=100)
evaluate ($saprotocol.mass=100)
evaluate ($fileroot="")
evaluate ($filenames.fileroot=$fileroot)
!evaluate ($filenames.template=$fileroot + "_1.pdb")

evaluate ($iterations.ini_count    =1)
evaluate ($iterations.w_vdw        =$w_vdw_$iteration)
evaluate ($iterations.w_elec       =$w_elec_$iteration)
evaluate ($iterations.w_dist       =$w_dist_$iteration)
evaluate ($iterations.w_rg         =$w_rg_$iteration)
evaluate ($iterations.w_sani       =$w_sani_$iteration)
evaluate ($iterations.w_xrdc       =$w_xrdc_$iteration)
evaluate ($iterations.w_xpcs       =$w_xpcs_$iteration)
evaluate ($iterations.w_dani       =$w_dani_$iteration)
evaluate ($iterations.w_vean       =$w_vean_$iteration)
evaluate ($iterations.w_cdih       =$w_cdih_$iteration)
evaluate ($iterations.w_sym        =$w_sym_$iteration)
evaluate ($iterations.w_zres       =$w_zres_$iteration)
evaluate ($iterations.w_bsa        =$w_bsa_$iteration)
evaluate ($iterations.w_deint      =$w_deint_$iteration)
evaluate ($iterations.w_desolv     =$w_desolv_$iteration)
evaluate ($iterations.anastruc     =$anastruc_$iteration)
evaluate ($iterations.w_lcc        =$w_lcc_$iteration)


evaluate ($data.ncomponents=$ncomponents)
!
evaluate ($nmol=1)
while ($nmol <= $data.ncomponents) loop mol
!
!  !aa topology, linkage and parameters files
!  evaluate ($toppar.prot_top_$nmol=$prot_top_mol$nmol )
!  evaluate ($toppar.prot_link_$nmol=$prot_link_mol$nmol )
!  evaluate ($toppar.prot_par_$nmol=$prot_par_mol$nmol )
!
!  !coarse grained topology, linkage and parameters files
!  evaluate ($toppar.prot_cg_top_$nmol=$prot_cg_top_mol$nmol )
!  evaluate ($toppar.prot_cg_link_$nmol=$prot_cg_link_mol$nmol )
!  evaluate ($toppar.prot_cg_par_$nmol=$prot_cg_par_mol$nmol )
!
!  !molecule related (coordinate files, rootname, fix, type, coarse grained, segid)
!  evaluate ($toppar.prot_coor_$nmol=$prot_coor_mol$nmol)
!  evaluate ($toppar.prot_root_$nmol=$prot_root_mol$nmol)
  !evaluate ($toppar.fix_origin_$nmol=$fix_origin_mol$nmol)
  evaluate ($toppar.fix_origin_$nmol=false)
  !evaluate ($toppar.dna_$nmol=$dna_mol$nmol)
  !evaluate ($toppar.cyclicpept_$nmol = $cyclicpept_mol$nmol)
  !evaluate ($toppar.shape_$nmol = $shape_mol$nmol)
  !evaluate ($toppar.cg_$nmol = $cg_mol$nmol)
  evaluate ($toppar.prot_segid_$nmol = $prot_segid_$nmol)

  !semi flexible segments
  evaluate ($toppar.nseg_$nmol = $nseg_$nmol)
  evaluate ($nseg = 1)
  while ($nseg <=$toppar.nseg_$nmol) loop seg
    evaluate ($toppar.start_seg_$nmol_$nseg = $start_seg_$nmol_$nseg)
    evaluate ($toppar.end_seg_$nmol_$nseg = $end_seg_$nmol_$nseg)
    evaluate ($nseg = $nseg + 1)
  end loop seg

  !fully flexible segments
  evaluate ($toppar.nfle_$nmol = $nfle_$nmol)
  evaluate ($nfle = 1)
  while ($nfle <=$toppar.nfle_$nmol) loop fle
    evaluate ($toppar.start_fle_$nmol_$nfle = $start_fle_$nmol_$nfle)
    evaluate ($toppar.end_fle_$nmol_$nfle = $end_fle_$nmol_$nfle)
    evaluate ($nfle = $nfle + 1)
  end loop fle
!
!  !histidine patches
  evaluate ($toppar.autohis = $autohis)
!  evaluate ($toppar.nhisd_$nmol = $numhisd_$nmol)
!  evaluate ($ncc=1)
!  while ($ncc <=$toppar.nhisd_$nmol) loop hisd
!    evaluate ($toppar.hisd_resid_$nmol_$ncc = $hisd_$nmol_$ncc)
!    evaluate ($ncc = $ncc + 1)
!  end loop hisd
!
!  evaluate ($toppar.nhise_$nmol = $numhise_$nmol)
!  evaluate ($ncc=1)
!  while ($ncc <=$toppar.nhise_$nmol) loop hisd
!    evaluate ($toppar.hise_resid_$nmol_$ncc = $hise_$nmol_$ncc)
!    evaluate ($ncc = $ncc + 1)
!  end loop hisd
!
  evaluate ($nmol = $nmol + 1)
end loop mol

! non-bonded parameter set to use
evaluate ($toppar.par_nonbonded = $par_nonbonded)

! z-restraining
evaluate ($Data.flags.zres = $zres_on)
evaluate ($data.numzres = $numzres)
evaluate ($ncc=1)
while ($ncc <= $numzres) loop zres
  evaluate ($toppar.zres_sta_$ncc = $zres_sta_$ncc)
  evaluate ($toppar.zres_end_$ncc = $zres_end_$ncc)
  evaluate ($toppar.zres_seg_$ncc = $zres_seg_$ncc)
  evaluate ($toppar.zres_type_$ncc = $zres_type_$ncc)
  evaluate ($ncc = $ncc + 1)
end loop zres

! NCS restraints
evaluate ($data.kncs = $kncs)
evaluate ($Data.flags.ncs = $ncs_on)
evaluate ($data.numncs = $numncs)
evaluate ($ncc=1)
while ($ncc <= $numncs) loop ncs
  evaluate ($toppar.ncs_sta1_$ncc = $ncs_sta1_$ncc)
  evaluate ($toppar.ncs_end1_$ncc = $ncs_end1_$ncc)
  evaluate ($toppar.ncs_seg1_$ncc = $ncs_seg1_$ncc)
  evaluate ($toppar.ncs_sta2_$ncc = $ncs_sta2_$ncc)
  evaluate ($toppar.ncs_end2_$ncc = $ncs_end2_$ncc)
  evaluate ($toppar.ncs_seg2_$ncc = $ncs_seg2_$ncc)
  evaluate ($ncc = $ncc + 1)
end loop ncs

! Symmetry restraints
evaluate ($data.ksym = $ksym)
evaluate ($Data.flags.sym = $sym_on)
evaluate ($data.numc2sym = $numc2sym)
evaluate ($nsym=1)
while ($nsym <= $numc2sym) loop sym
  evaluate ($toppar.c2sym_sta1_$nsym = $c2sym_sta1_$nsym)
  evaluate ($toppar.c2sym_end1_$nsym = $c2sym_end1_$nsym)
  evaluate ($toppar.c2sym_seg1_$nsym = $c2sym_seg1_$nsym)
  evaluate ($toppar.c2sym_sta2_$nsym = $c2sym_sta2_$nsym)
  evaluate ($toppar.c2sym_end2_$nsym = $c2sym_end2_$nsym)
  evaluate ($toppar.c2sym_seg2_$nsym = $c2sym_seg2_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc3sym = $numc3sym)
evaluate ($nsym=1)
while ($nsym <= $numc3sym) loop sym
  evaluate ($toppar.c3sym_sta1_$nsym = $c3sym_sta1_$nsym)
  evaluate ($toppar.c3sym_end1_$nsym = $c3sym_end1_$nsym)
  evaluate ($toppar.c3sym_seg1_$nsym = $c3sym_seg1_$nsym)
  evaluate ($toppar.c3sym_sta2_$nsym = $c3sym_sta2_$nsym)
  evaluate ($toppar.c3sym_end2_$nsym = $c3sym_end2_$nsym)
  evaluate ($toppar.c3sym_seg2_$nsym = $c3sym_seg2_$nsym)
  evaluate ($toppar.c3sym_sta3_$nsym = $c3sym_sta3_$nsym)
  evaluate ($toppar.c3sym_end3_$nsym = $c3sym_end3_$nsym)
  evaluate ($toppar.c3sym_seg3_$nsym = $c3sym_seg3_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.nums3sym= $nums3sym)
evaluate ($nsym=1)
while ($nsym <= $nums3sym) loop sym
  evaluate ($toppar.s3sym_sta1_$nsym = $s3sym_sta1_$nsym)
  evaluate ($toppar.s3sym_end1_$nsym = $s3sym_end1_$nsym)
  evaluate ($toppar.s3sym_seg1_$nsym = $s3sym_seg1_$nsym)
  evaluate ($toppar.s3sym_sta2_$nsym = $s3sym_sta2_$nsym)
  evaluate ($toppar.s3sym_end2_$nsym = $s3sym_end2_$nsym)
  evaluate ($toppar.s3sym_seg2_$nsym = $s3sym_seg2_$nsym)
  evaluate ($toppar.s3sym_sta3_$nsym = $s3sym_sta3_$nsym)
  evaluate ($toppar.s3sym_end3_$nsym = $s3sym_end3_$nsym)
  evaluate ($toppar.s3sym_seg3_$nsym = $s3sym_seg3_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc4sym = $numc4sym)
evaluate ($nsym=1)
while ($nsym <= $numc4sym) loop sym
  evaluate ($toppar.c4sym_sta1_$nsym = $c4sym_sta1_$nsym)
  evaluate ($toppar.c4sym_end1_$nsym = $c4sym_end1_$nsym)
  evaluate ($toppar.c4sym_seg1_$nsym = $c4sym_seg1_$nsym)
  evaluate ($toppar.c4sym_sta2_$nsym = $c4sym_sta2_$nsym)
  evaluate ($toppar.c4sym_end2_$nsym = $c4sym_end2_$nsym)
  evaluate ($toppar.c4sym_seg2_$nsym = $c4sym_seg2_$nsym)
  evaluate ($toppar.c4sym_sta3_$nsym = $c4sym_sta3_$nsym)
  evaluate ($toppar.c4sym_end3_$nsym = $c4sym_end3_$nsym)
  evaluate ($toppar.c4sym_seg3_$nsym = $c4sym_seg3_$nsym)
  evaluate ($toppar.c4sym_sta4_$nsym = $c4sym_sta4_$nsym)
  evaluate ($toppar.c4sym_end4_$nsym = $c4sym_end4_$nsym)
  evaluate ($toppar.c4sym_seg4_$nsym = $c4sym_seg4_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

evaluate ($data.numc5sym=$numc5sym)
evaluate ($nsym=1)
while ($nsym <= $numc5sym) loop sym
  evaluate ($toppar.c5sym_sta1_$nsym = $c5sym_sta1_$nsym)
  evaluate ($toppar.c5sym_end1_$nsym = $c5sym_end1_$nsym)
  evaluate ($toppar.c5sym_seg1_$nsym = $c5sym_seg1_$nsym)
  evaluate ($toppar.c5sym_sta2_$nsym = $c5sym_sta2_$nsym)
  evaluate ($toppar.c5sym_end2_$nsym = $c5sym_end2_$nsym)
  evaluate ($toppar.c5sym_seg2_$nsym = $c5sym_seg2_$nsym)
  evaluate ($toppar.c5sym_sta3_$nsym = $c5sym_sta3_$nsym)
  evaluate ($toppar.c5sym_end3_$nsym = $c5sym_end3_$nsym)
  evaluate ($toppar.c5sym_seg3_$nsym = $c5sym_seg3_$nsym)
  evaluate ($toppar.c5sym_sta4_$nsym = $c5sym_sta4_$nsym)
  evaluate ($toppar.c5sym_end4_$nsym = $c5sym_end4_$nsym)
  evaluate ($toppar.c5sym_seg4_$nsym = $c5sym_seg4_$nsym)
  evaluate ($toppar.c5sym_sta5_$nsym = $c5sym_sta5_$nsym)
  evaluate ($toppar.c5sym_end5_$nsym = $c5sym_end5_$nsym)
  evaluate ($toppar.c5sym_seg5_$nsym = $c5sym_seg5_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym


evaluate ($data.numc6sym=$numc6sym)
evaluate ($nsym=1)
while ($nsym <= $numc6sym) loop sym
  evaluate ($toppar.c6sym_sta1_$nsym = $c6sym_sta1_$nsym)
  evaluate ($toppar.c6sym_end1_$nsym = $c6sym_end1_$nsym)
  evaluate ($toppar.c6sym_seg1_$nsym = $c6sym_seg1_$nsym)
  evaluate ($toppar.c6sym_sta2_$nsym = $c6sym_sta2_$nsym)
  evaluate ($toppar.c6sym_end2_$nsym = $c6sym_end2_$nsym)
  evaluate ($toppar.c6sym_seg2_$nsym = $c6sym_seg2_$nsym)
  evaluate ($toppar.c6sym_sta3_$nsym = $c6sym_sta3_$nsym)
  evaluate ($toppar.c6sym_end3_$nsym = $c6sym_end3_$nsym)
  evaluate ($toppar.c6sym_seg3_$nsym = $c6sym_seg3_$nsym)
  evaluate ($toppar.c6sym_sta4_$nsym = $c6sym_sta4_$nsym)
  evaluate ($toppar.c6sym_end4_$nsym = $c6sym_end4_$nsym)
  evaluate ($toppar.c6sym_seg4_$nsym = $c6sym_seg4_$nsym)
  evaluate ($toppar.c6sym_sta5_$nsym = $c6sym_sta5_$nsym)
  evaluate ($toppar.c6sym_end5_$nsym = $c6sym_end5_$nsym)
  evaluate ($toppar.c6sym_seg5_$nsym = $c6sym_seg5_$nsym)
  evaluate ($toppar.c6sym_sta6_$nsym = $c6sym_sta6_$nsym)
  evaluate ($toppar.c6sym_end6_$nsym = $c6sym_end6_$nsym)
  evaluate ($toppar.c6sym_seg6_$nsym = $c6sym_seg6_$nsym)
  evaluate ($nsym = $nsym + 1)
end loop sym

if ( data.numc2sym eq 6) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc3sym ne 0) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc4sym ne 0) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc5sym ne 0) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if
if ( data.numc6sym ne 0) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
end if


!Dihedrals, DNA and distance restraints
evaluate ($Data.dnarest =$dnarest_on)
evaluate ($Data.flags.cdih =$dihedrals_on)
evaluate ($Data.cdih.on =$dihedrals_on)
evaluate ($Data.ssdihed =$ssdihed)
evaluate ($Data.error_dih =$error_dih)
evaluate ($data.dihedrals.on=$dihedrals_on)
evaluate ($data.dihedrals_hot=$dihedrals_hot)
evaluate ($data.dihedrals_cool1=$dihedrals_cool1)
evaluate ($data.dihedrals_cool2=$dihedrals_cool2)
evaluate ($data.dihedrals_cool3=$dihedrals_cool3)
evaluate ($data.hbonds_on=$hbonds_on)

! RDC restraints
evaluate ($Data.flags.vean =  false)
evaluate ($Data.flags.xrdc =  false)
evaluate ($Data.flags.sani =  false)
evaluate ($data.numrdc=$numrdc)
evaluate ($ncc=1)
while ($ncc <=$data.numrdc) loop rdc
  if ($rdc_choice_$ncc = "VANGLE") then
    evaluate ($Data.flags.vean =  true)
  end if
  if ($rdc_choice_$ncc = "SANI") then
    evaluate ($Data.flags.sani =  true)
  end if
  if ($rdc_choice_$ncc = "XRDC") then
    evaluate ($Data.flags.xrdc =  true)
  end if
  evaluate ($data.rdc_choice_$ncc=$rdc_choice_$ncc)
  evaluate ($data.rdc_firstIt_$ncc=$rdc_firstIt_$ncc)
  evaluate ($data.rdc_lastIt_$ncc=$rdc_lastIt_$ncc)
  evaluate ($data.rdc_hot_$ncc=$rdc_hot_$ncc)
  evaluate ($data.rdc_cool1_$ncc=$rdc_cool1_$ncc)
  evaluate ($data.rdc_cool2_$ncc=$rdc_cool2_$ncc)
  evaluate ($data.rdc_cool3_$ncc=$rdc_cool3_$ncc)
  evaluate ($data.rdc_r_$ncc=$rdc_r_$ncc)
  evaluate ($data.rdc_d_$ncc=$rdc_d_$ncc)
  evaluate ($data.ini_bor_hot_$ncc=$ini_bor_hot_$ncc)
  evaluate ($data.ini_bor_cool1_$ncc=$ini_bor_cool1_$ncc)
  evaluate ($data.ini_bor_cool2_$ncc=$ini_bor_cool2_$ncc)
  evaluate ($data.ini_bor_cool3_$ncc=$ini_bor_cool3_$ncc)
  evaluate ($data.ini_cen_hot_$ncc=$ini_cen_hot_$ncc)
  evaluate ($data.ini_cen_cool1_$ncc=$ini_cen_cool1_$ncc)
  evaluate ($data.ini_cen_cool2_$ncc=$ini_cen_cool2_$ncc)
  evaluate ($data.ini_cen_cool3_$ncc=$ini_cen_cool3_$ncc)
  evaluate ($data.fin_bor_hot_$ncc=$fin_bor_hot_$ncc)
  evaluate ($data.fin_bor_cool1_$ncc=$fin_bor_cool1_$ncc)
  evaluate ($data.fin_bor_cool2_$ncc=$fin_bor_cool2_$ncc)
  evaluate ($data.fin_bor_cool3_$ncc=$fin_bor_cool3_$ncc)
  evaluate ($data.fin_cen_hot_$ncc=$fin_cen_hot_$ncc)
  evaluate ($data.fin_cen_cool1_$ncc=$fin_cen_cool1_$ncc)
  evaluate ($data.fin_cen_cool2_$ncc=$fin_cen_cool2_$ncc)
  evaluate ($data.fin_cen_cool3_$ncc=$fin_cen_cool3_$ncc)
  evaluate ($ncc=$ncc+1)
end loop rdc

! PCS restraints
evaluate ($Data.flags.xpcs =  false)
evaluate ($data.numpcs=$numpcs)
evaluate ($ncc=1)
while ($ncc <=$numpcs) loop pcs
  if ($pcs_choice_$ncc = "XPCS") then
    evaluate ($Data.flags.xpcs =  true)
  end if
  evaluate ($data.pcs_choice_$ncc=$pcs_choice_$ncc)
  evaluate ($data.pcs_firstIt_$ncc=$pcs_firstIt_$ncc)
  evaluate ($data.pcs_lastIt_$ncc=$pcs_lastIt_$ncc)
  evaluate ($data.pcs_hot_$ncc=$pcs_hot_$ncc)
  evaluate ($data.pcs_cool1_$ncc=$pcs_cool1_$ncc)
  evaluate ($data.pcs_cool2_$ncc=$pcs_cool2_$ncc)
  evaluate ($data.pcs_cool3_$ncc=$pcs_cool3_$ncc)
  evaluate ($data.pcs_r_$ncc=$pcs_r_$ncc)
  evaluate ($data.pcs_d_$ncc=$pcs_d_$ncc)
  evaluate ($ncc=$ncc+1)
end loop pcs

! DANI restraints
evaluate ($Data.flags.dani =  false)
evaluate ($data.numdani=$numdani)
evaluate ($ncc=1)
while ($ncc <=$numdani) loop dani
  if ($dan_choice_$ncc = "DANI") then
    evaluate ($Data.flags.dani =  true)
  end if
  evaluate ($data.dan_choice_$ncc=$dan_choice_$ncc)
  evaluate ($data.dan_firstIt_$ncc=$dan_firstIt_$ncc)
  evaluate ($data.dan_lastIt_$ncc=$dan_lastIt_$ncc)
  evaluate ($data.dan_hot_$ncc=$dan_hot_$ncc)
  evaluate ($data.dan_cool1_$ncc=$dan_cool1_$ncc)
  evaluate ($data.dan_cool2_$ncc=$dan_cool2_$ncc)
  evaluate ($data.dan_cool3_$ncc=$dan_cool3_$ncc)
  evaluate ($data.dan_tc_$ncc=$dan_tc_$ncc)
  evaluate ($data.dan_anis_$ncc=$dan_anis_$ncc)
  evaluate ($data.dan_r_$ncc=$dan_r_$ncc)
  evaluate ($data.dan_wh_$ncc=$dan_wh_$ncc)
  evaluate ($data.dan_wn_$ncc=$dan_wn_$ncc)
  evaluate ($ncc=$ncc+1)
end loop dani

! planarity restraints
evaluate ($Data.flags.plan =  false)

! distance restraints
evaluate ($Data.flags.noe  =  true)
evaluate ($data.scaling=$air_scaling)
evaluate ($data.totnoe_unamb=$tot_unamb)
evaluate ($data.unamb_firstit=$unamb_firstit)
evaluate ($data.unamb_lastit=$unamb_lastit)
evaluate ($data.unamb_hot=$unamb_hot)
evaluate ($data.unamb_cool1=$unamb_cool1)
evaluate ($data.unamb_cool2=$unamb_cool2)
evaluate ($data.unamb_cool3=$unamb_cool3)
evaluate ($data.noecv=$noecv)
evaluate ($data.ncvpart=$ncvpart)

evaluate ($data.totnoe_amb=$tot_amb)
evaluate ($data.amb_firstit=$amb_firstit)
evaluate ($data.amb_lastit=$amb_lastit)
evaluate ($data.amb_hot=$amb_hot)
evaluate ($data.amb_cool1=$amb_cool1)
evaluate ($data.amb_cool2=$amb_cool2)
evaluate ($data.amb_cool3=$amb_cool3)

evaluate ($data.hbond_firstit=$hbond_firstit)
evaluate ($data.hbond_lastit=$hbond_lastit)
evaluate ($data.hbond_hot=$hbond_hot)
evaluate ($data.hbond_cool1=$hbond_cool1)
evaluate ($data.hbond_cool2=$hbond_cool2)
evaluate ($data.hbond_cool3=$hbond_cool3)

evaluate ($data.mrswi_hot=$mrswi_hot)
evaluate ($data.mrswi_cool1=$mrswi_cool1)
evaluate ($data.mrswi_cool2=$mrswi_cool2)
evaluate ($data.mrswi_cool3=$mrswi_cool3)

evaluate ($data.rswi_hot=$rswi_hot)
evaluate ($data.rswi_cool1=$rswi_cool1)
evaluate ($data.rswi_cool2=$rswi_cool2)
evaluate ($data.rswi_cool3=$rswi_cool3)

evaluate ($data.masy_hot=$masy_hot)
evaluate ($data.masy_cool1=$masy_cool1)
evaluate ($data.masy_cool2=$masy_cool2)
evaluate ($data.masy_cool3=$masy_cool3)

evaluate ($data.asy_hot=$asy_hot)
evaluate ($data.asy_cool1=$asy_cool1)
evaluate ($data.asy_cool2=$asy_cool2)
evaluate ($data.asy_cool3=$asy_cool3)

evaluate ($data.ranair=$ranair)
if ($data.ranair eq true) then
  evaluate ($data.noecv = false)
end if
evaluate ($data.cmrest=$cmrest)
evaluate ($data.cmtight=$cmtight)
evaluate ($data.kcont=$kcont)
evaluate ($data.surfrest=$surfrest)
evaluate ($data.ksurf=$ksurf)


! radius of gydration restraints
evaluate ($data.flags.rg=$rgrest)
evaluate ($data.rgtarg=$rgtarg)
evaluate ($data.krg_hot=$krg_hot)
evaluate ($data.krg_cool1=$krg_cool1)
evaluate ($data.krg_cool2=$krg_cool2)
evaluate ($data.krg_cool3=$krg_cool3)
evaluate ($data.rgsele=$rgsele)

evaluate ($data.kzres=$kzres)
evaluate ($data.zresmax=$zresmax)
evaluate ($data.zresmin=$zresmin)

! keep or delete non-polar hydrogens
evaluate ($toppar.delenph=$delenph)


!Electrostatics:
evaluate ($Data.flags.dihed =$dihedflag)
evaluate ($Data.flags.elec0 =$elecflag_0)
evaluate ($Data.flags.elec1 =$elecflag_1)
evaluate ($Data.epsilon0 =$epsilon_0)
evaluate ($Data.epsilon1 =$epsilon_1)
evaluate ($Data.dielec0  =$dielec_0)
evaluate ($Data.dielec1  =$dielec_1)


!Interaction matrix:
evaluate ($nmol1=1)
while ($nmol1 <=$data.ncomponents) loop mol1
  evaluate ($nmol2=$nmol1 + 1)
  evaluate ($toppar.int_$nmol1_$nmol1 =int_$nmol1_$nmol1)
  while ($nmol2 <=$data.ncomponents) loop mol2
    evaluate ($toppar.int_$nmol1_$nmol2 =$int_$nmol1_$nmol2)
    evaluate ($toppar.int_$nmol2_$nmol1 =$int_$nmol1_$nmol2)
    evaluate ($nmol2=$nmol2 + 1)
  end loop mol2
  evaluate ($nmol1 = $nmol1 + 1)
end loop mol1

!intermolecular contacts analysis
evaluate ($data.hb_dist=$dist_hb)
evaluate ($data.nb_dist=$dist_nb)


!water refinement
evaluate ($refine.firstwater=$firstwater)
evaluate ($refine.solvshell=$solvshell)
evaluate ($refine.keepwater=$keepwater)
!evaluate ($refine.waterrefine=$min($structures_1,waterrefine))
evaluate ($refine.solvent=$solvent)
evaluate ($refine.heatsteps=$waterheatsteps)
evaluate ($refine.steps=$watersteps)
evaluate ($refine.coolsteps=$watercoolsteps)


!for the non-bonded parameters (the section was taken out of
!parallhdg5.0.pro and parallhdg5.1.pro, so be careful!):
if ($toppar.par_nonbonded eq "PROLSQ") then
    evaluate ($toppar.repel_radius = 1.0)
    evaluate ($toppar.repel_rcons = 20)
    evaluate ($toppar.repel_rexpo  = 4)
    evaluate ($toppar.repel_irexp  = 1)
elseif ($toppar.par_nonbonded eq "PARMALLH6") then
    evaluate ($toppar.repel_radius = 0.8)
    evaluate ($toppar.repel_rcons = 5.0)
    evaluate ($toppar.repel_rexpo  = 2)
    evaluate ($toppar.repel_irexp  = 2)
elseif ($toppar.par_nonbonded eq "OPLSX") then
    evaluate ($toppar.repel_radius = 0.0)
else        {...now the standard PARALLHDG parameters}
    evaluate ($toppar.repel_radius = 0.78)
    evaluate ($toppar.repel_rcons = 5.0)
    evaluate ($toppar.repel_rexpo  = 2)
    evaluate ($toppar.repel_irexp  = 2)
end if

! Water in rigid body docking
evaluate ($data.waterdock=$waterdock)
evaluate ($data.db_method=$db_method)
evaluate ($data.water_tokeep=$water_tokeep)
evaluate ($data.dnap_water_tokeep=$dnap_water_tokeep)
evaluate ($data.water_randfrac=$water_randfrac)
evaluate ($data.solvate_method=$solvate_method)
evaluate ($data.water_surfcutoff=$water_surfcutoff)
evaluate ($data.water_analysis=$water_analysis)
evaluate ($data.transwater=$transwater)
evaluate ($data.water_restraint_initial=$water_restraint_initial)
evaluate ($data.water_restraint_cutoff=$water_restraint_cutoff)
evaluate ($data.water_restraint_scale=$water_restraint_scale)
evaluate ($data.waterensemble=$waterensemble)

if ($data.waterdock eq true) then
  evaluate ($saprotocol.rotate180_it0 = false)
  evaluate ($saprotocol.rotate180_it1 = false)
  evaluate ($SaProtocol.initiosteps = 0)
  evaluate ($SaProtocol.cool1_steps = 0)
  evaluate ($refine.keepwater = true)
  display SOLVATED DOCKING TURNED ON: initiosteps and cool1_steps set to 0, rotate180 set to false
end if

! Centroid parameters
evaluate ($data.flags.centroids =$centroid_rest)
evaluate ($data.centroids.kscale =$centroid_kscale)
evaluate ($nchain = 0)
while ($nchain < $data.ncomponents) loop nloop1
    evaluate ($nchain = $nchain + 1)
    evaluate ($data.centroids.xcom_$nchain =$xcom_$nchain)
    evaluate ($data.centroids.ycom_$nchain =$ycom_$nchain)
    evaluate ($data.centroids.zcom_$nchain =$zcom_$nchain)
    evaluate ($data.centroids.ambi_$nchain =$ambi_$nchain)
end loop nloop1

if ($saprotocol.expand eq true) then
  evaluate ($data.flags.centroids = true)
end if

! Cryo-EM parameters
evaluate ($data.flags.em =$em_rest)
evaluate ($data.em.kscale =$em_kscale)
evaluate ($data.em.it0 =$em_it0)
evaluate ($data.em.it1 =$em_it1)
evaluate ($data.em.itw =$em_itw)
evaluate ($data.em.resolution =$em_resolution)
evaluate ($data.em.nx =$nx)
evaluate ($data.em.ny =$ny)
evaluate ($data.em.nz =$nz)
evaluate ($data.em.xlength =$xlength)
evaluate ($data.em.ylength =$ylength)
evaluate ($data.em.zlength =$zlength)

! Restraints
evaluate ($npart = $ncvpart)

!==================================================================!

if ( $log_level = "verbose" ) then
   set message=normal echo=on end
else
   set message=off echo=off end
end if

noe
  averaging  * sum
  potential  * soft
  scale      * 1.0
  sqconstant * 1.0
  sqexponent * 2
  soexponent * 1
  rswitch    * 1.0
  sqoffset   * 0.0
  asymptote  * 2.0
  msoexponent * 1
  masymptote  * -0.1
  mrswitch    * 1.0
  avexpo hbond 20
end

!fileexist $errfile end
!      if ($result eq false) then
!
!fileexist $ambig_fname end
!if ($result eq true) then
!    noe class ambi @@$ambig_fname end
!end if
!
!fileexist $unambig_fname end
!if ($result eq true) then
!    noe class dist @@$unambig_fname end
!end if

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!The next line will be changed automatically from python:
evaluate ($whichMD="torsion")
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!The next line will be changed automatically from python:
evaluate ($count = 1)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!The next line will be changed automatically from python:
evaluate ($file = "")
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!reads in structure, coordinates and parameter files

@RUN:read_struc.cns

flag include bond angle impr vdw end

if ($Data.flags.dihed eq true) then
  flag include dihed end
end if

do (fbeta=$Saprotocol.fbeta) (all)
do (mass=$Saprotocol.mass) (all)
do (mass=1000) (resn ani)
do (mass=1000) (resn xan)
do (mass=1000) (resn dan)

!evaluate ($end_count = $iterations.ini_count + $iterations.structures - 1)
!evaluate ($end_count = $iterations.ini_count + $structures_0)

! What is the purpose of this?
!if ($Data.noecv eq true) then
!  evaluate ($npart = 1 + mod($count,$Data.ncvpart))
!    evaluate ($fileseed="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".seed")
!  evaluate ($fileseed="NEWIT:complex" + "_" + encode($count) + ".seed")

!  evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed)
evaluate ($fileseed=$output_pdb_filename - ".pdb" + ".seed")
set display=$fileseed end
display module(seed;npart)
display define (
display currentseed = $seed;
display currentpart = $npart;
display )
display evaluate (&seed=currentseed)
display evaluate (&npart=currentpart)
close $fileseed end

!else
!  evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed)
!end if

!display $seed
set seed $seed end

!coor init end
!coor @@$file

! reinitialize the DUM residue
if ($Data.flags.centroids = true) then
    if ($iteration = 0) then
        @RUN:centroids_initialize.cns
    end if
end if

{* Find CoM of protein *}
show ave (x) (name CA or name BB or name C1')
evaluate ($xcent=$result)
show ave (y) (name CA or name BB or name C1')
evaluate ($ycent=$result)
show ave (z) (name CA or name BB or name C1')
evaluate ($zcent=$result)

coor select (not known and resn ani) end
if ($select gt 0) then
  coor @@$tensor_pdb

  {* Find CoM of protein and move tensor 100 A away *}
  show ave (x) (name CA or name BB or name C1')
  evaluate ($xcent=$result)
  show ave (y) (name CA or name BB or name C1')
  evaluate ($ycent=$result)
  show ave (z) (name CA or name BB or name C1')
  evaluate ($zcent=$result)
  do (x=x+$xcent+100) (resn ANI)
  do (y=y+$ycent+100) (resn ANI)
  do (z=z+$zcent+100) (resn ANI)
  evaluate ($rantens = true)
else
  evaluate ($rantens = false)
end if

coor select (not known and resn xan) end
if ($select gt 0) then
  coor @@$tensor_para_pdb
  evaluate ($rantens_para = true)
else
  evaluate ($rantens_para = false)
end if

coor select (not known and resn dan) end
if ($select gt 0) then
!  coor @@RUN:toppar/tensor_dani.pdb
  coor @@toppar/tensor_dani.pdb

  {* Find CoM of protein and move tensor 100 A away *}
  show ave (x) (name CA or name BB or name C1')
  evaluate ($xcent=$result)
  show ave (y) (name CA or name BB or name C1')
  evaluate ($ycent=$result)
  show ave (z) (name CA or name BB or name C1')
  evaluate ($zcent=$result)
  do (x=x+$xcent+100) (resn DAN)
  do (y=y+$ycent+100) (resn DAN)
  do (z=z+$zcent+100) (resn DAN)
  evaluate ($rantens_dani = true)
else
  evaluate ($rantens_dani = false)
end if

!catch possible bound water and set high T steps to 0
coor select ((resn WAT or resn HOH or resn TIP*)) end
if ($select gt 0) then
  evaluate ($SaProtocol.initiosteps = 0)
  evaluate ($SaProtocol.cool1_steps = 0)
  evaluate ($refine.keepwater = true)
end if

do (refx=x) (all)
do (refy=y) (all)
do (refz=z) (all)

!set the energy flags:
inline @RUN:setflags.cns

!read all the experimental Data:
evaluate ($lcc = 0)
set seed $seed end
set message=normal echo=on end
if ($data.waterdock eq false) then
    inline @RUN:read_data.cns
    if ($data.flags.em = true) then
!        @RUN:em_read_data.cns(Data=$data;)
        @RUN:em_read_data.cns
    end if

    if ($Data.flags.centroids = true) then
        if ($iteration = 0) then
            @RUN:centroids_set_restraints.cns
        end if
    end if
end if

{* ======================= reset coordinates and proceed *}

do (x = refx) (all)
do (y = refy) (all)
do (z = refz) (all)

inline @RUN:read_water1.cns
if ($data.waterdock eq true) then
  inline @RUN:water_rest.cns
  set seed $seed end
  set message=normal echo=on end
  inline @RUN:read_data.cns
end if

!set the energy flags:
inline @RUN:setflags.cns

{* random removal of restaints ================================== *}
if ($Data.noecv eq true) then
  set message=on echo=on end
  noe cv $npart ? end
else
  evaluate ($npart = 0)
end if

if ( $log_level = "verbose" ) then
   set message=normal echo=on end
else
   set message=off echo=off end
end if

!set the rdc coefficients:
evaluate ($nrdc=1)
while ($nrdc <= $data.numrdc) loop rdc
  evaluate ($cln = "rd" + encode($nrdc) )
  if ($Data.rdc_choice_$nrdc eq "SANI") then
    sani class $cln coeff 0.0 $Data.rdc_d_$nrdc $Data.rdc_r_$nrdc end
  end if
  if ($Data.rdc_choice_$nrdc eq "XRDC") then
    xrdc class $cln coeff $Data.rdc_d_$nrdc $Data.rdc_r_$nrdc end
  end if
  evaluate ($nrdc=$nrdc+1)
end loop rdc

!set the pcs coefficients:
evaluate ($npcs=1)
while ($npcs <= $data.numpcs) loop pcs
  if ($Data.pcs_choice_$npcs eq "XPCS") then
    evaluate ($cln = "pc"+encode($npcs) )
    xpcs class $cln coeff $Data.pcs_d_$npcs $Data.pcs_r_$npcs end
  end if
  evaluate ($npcs=$npcs+1)
end loop pcs

! set dani coefficients:
evaluate ($ndani=1)
while ($ndani <= $data.numdani) loop dani
  if ($Data.dan_choice_$ndani eq "DANI") then
    evaluate ($cln = "da"+encode($ndani) )
    dani class $cln coeff $Data.dan_tc_$ndani $Data.dan_anis_$ndani $Data.dan_r_$ndani $Data.dan_wh_$ndani $Data.dan_wn_$ndani end
  end if
  evaluate ($ndani=$ndani+1)
end loop dani


{* ============================================================== *}
eval ($anisotropy = false)
if ($Data.flags.sani eq true) then
  flag incl sani end
  eval ($anisotropy = true)
else
  flag excl sani end
end if

if ($Data.flags.xrdc eq true) then
  flag incl xrdc end
  eval ($anisotropy = true)
else
  flag excl xrdc end
end if

if ($Data.flags.xpcs eq true) then
  flag incl xpcs end
  eval ($anisotropy = true)
else
  flag excl xpcs end
end if

if ($Data.flags.vean eq true) then
  flag incl vean end
else
  flag excl vean end
end if

if ($Data.flags.dani eq true) then
  flag incl dani end
  eval ($anisotropy = true)
else
  flag excl dani end
end if

! determine whether the final models should be reoriented along their principal
! axes before writing to file in it0 and it1
eval($reorient = true)
if ($data.flags.zres = true) then
    eval($reorient = false)
elseif ($data.flags.em = true) then
    eval($reorient = false)
elseif ($data.flags.centroids = true) then
    eval($reorient = false)
end if
! also check for fixed molecules
evaluate ($ncount = 0)
while ($ncount < $data.ncomponents) loop orientmol
  evaluate ($ncount = $ncount + 1)
  if ($Toppar.fix_origin_$ncount eq true) then
    eval($reorient = false)
  end if
end loop orientmol


eval ($nchain1 = 0)
while ($nchain1 < $data.ncomponents) loop nloop1
  eval($nchain1 = $nchain1 + 1)
  if ($Toppar.fix_origin_$nchain1 eq true) then
    eval($reorient = false)
  end if
end loop nloop1

evaluate ($numnoe = 0)

{*======================= random orientations and rigid body minimisation *}
!if ($iteration = 0) then
  if ($SaProtocol.rigidmini eq true) then
    !Make sure that at least as many distance restraints are successfully
    !read as the number of partitions for cross-validation
    evaluate ($numnoe = 0)
    noe ? end
    if ($NUMNOE = 0) then
      if ($Data.ncomponents > 1) then
        if ($Data.surfrest eq FALSE) then
          if ($Data.cmrest eq FALSE) then
            if ($Data.ranair eq FALSE) then
              if ($Data.flags.rg eq FALSE) then
                evaluate ($errfile = "RUN:WARNING")
                fileexist $errfile end
                if ($result eq false) then
                  set display=$errfile end
                  display TOTAL NUMBER OF DISTANCE RESTRAINTS FOR RIGID BODY DOCKING IS ZERO!
                  display CONTROL YOUR PARAMETER SETTINGS AND RESTRAINT DEFINITIONS
                  display STRUCTURE NUMBER $count
                  close $errfile end
                end if
              end if
            end if
          end if
        end if
      end if
      evaluate ($Data.ncvpart = 1)
      evaluate ($Data.noecv = FALSE)
    end if
  end if

  if ($NUMNOE lt $Data.ncvpart) then
    noe part=1 end
    evaluate ($Data.ncvpart = 1)
    evaluate ($Data.noecv = FALSE)
  end if

  flag excl bond angl dihe impr zhar end

  if ($Data.flags.elec0 eq true) then
    flag include elec end
    if ($Data.dielec0 eq rdie) then
      parameter nbonds eps=$Data.epsilon0 rdie shift switch end end
      ! shift statement needed first to activate switch (CNS bug?)
    else
      parameter nbonds eps=$Data.epsilon0 cdie shift end end
    end if
    parameter nbonds ? end end
  else
    evaluate ($elec=0.0)
    flag exclude elec end
  end if

  flag excl cdih end

  if ($Data.ranair eq true) then
    if ($Data.ncomponents > 2) then
      evaluate ($errfile = "RUN:FAILED")
      fileexist $errfile end
      if ($result eq false) then
        set display=$errfile end
        display ========= Unsupported option ===========
        display Random definition of AIRs with more than
        display two molecules currently unsupported
        display ========================================
        close $errfile end
      end if
      stop
    end if
    evaluate ($Data.noecv = false)
    noe
      reset
      nrestraints = 100000     ! allocate space for NOEs
      ceiling 1000
    end
    @RUN:randomairs.cns

    !Read back in hbond data
    if ($Data.hbond_lastit ge &iteration) then
      if ($Data.hbond_firstit le &iteration) then
        if ($Data.hbonds_on eq true) then
          fileexist $hbond_fname end
          if ($result eq true) then
!            noe @@$hbond_fname end
            noe @@$hbond_fname end
          end if
        end if
      end if
    end if

    noe
      averaging  * sum
      potential  * soft
      scale      * 1.0
      sqconstant * 1.0
      sqexponent * 2
      soexponent * 1
      rswitch    * 1.0
      sqoffset   * 0.0
      asymptote  * 2.0
      msoexponent * 1
      masymptote  * -0.1
      mrswitch    * 1.0
      avexpo hbond 20
    end
    inline @RUN:water_rest.cns
  end if

  @RUN:symmultimer.cns

  @RUN:zrestraining.cns

  if ($Data.flags.rg eq true ) then
    collapse
      force  $Data.krg_hot
      target $Data.rgtarg
      sele   (not (resn ANI or resn XAN or resn WAT or resn HOH or resn TIP* or resn DUM or resh SHA))
    end
  end if

  if ($Data.cmrest eq true ) then
    @RUN:cm-restraints.cns
  end if

  if ($Data.surfrest eq true ) then
    @RUN:surf-restraints.cns
  end if

  if ($Data.flags.centroids eq true) then
      @RUN:centroids_initialize.cns
      @RUN:centroids_set_map.cns
      noe scale centroid $data.centroids.kscale end
  end if

  flag excl ncs end
  evaluate ($nrig = 0)
  evaluate ($nfirst = 1)
  evaluate ($bestair = 0)

  if ($SaProtocol.rigidmini eq true) then
    while ($nrig < $SaProtocol.ntrials) loop trials

      evaluate ($nrig = $nrig + 1)

      if ( $log_level = "verbose" ) then
        set message=normal echo=on end
       else
        set message=off echo=off end
      end if

      ! random placement of molecules
      if ($SaProtocol.randorien eq true) then
!          @RUN:separate.cns(Data=$Data; Toppar=$Toppar)
          @RUN:separate.cns
          @RUN:random_rotations.cns
          if ($Data.flags.centroids eq true) then
              ! place the centroids on their positions
              @RUN:centroids_initialize.cns
              @RUN:centroids_set_map.cns
              ! place the molecules around the centroids
              @RUN:centroids_init_placement.cns
          end if
      end if

      if ($Data.flags.sani eq true) then
!        coor @@$tensor_pdb
        coor @@$tensor_pdb
        do (x = x + $xcent + 100) (resn ANI)
        do (y = y + $ycent + 100) (resn ANI)
        do (z = z + $zcent + 100) (resn ANI)
      end if

      if ($Data.flags.dani eq true) then
!        coor @@RUN:toppar/tensor_dani.pdb
        coor @@$tensor_dani_pdb
        do (x=x+$xcent+100) (resn DAN)
        do (y=y+$ycent+100) (resn DAN)
        do (z=z+$zcent+100) (resn DAN)
      end if

      if ($Data.flags.xrdc eq true) then
!        coor @@$tensor_para_pdb
        coor @@$tensor_para_pdb
        do (x=x+$xcent+100) (resn XAN)
        do (y=y+$ycent+100) (resn XAN)
        do (z=z+$zcent+100) (resn XAN)
      end if

      if ($Data.flags.xpcs eq true) then
!        coor @@$tensor_para_pdb
        coor @@$tensor_para_pdb
        do (x=x+$xcent+100) (resn XAN)
        do (y=y+$ycent+100) (resn XAN)
        do (z=z+$zcent+100) (resn XAN)
      end if

      evaluate ($unamb_scale = 1.0)
      evaluate ($ambig_scale = 1.0)
      evaluate ($hbond_scale = 1.0)
      evaluate ($symm_scale = 1.0)
      evaluate ($cont_scale = 0.0)
      evaluate ($surf_scale = 0.0)

      noe
        scale dist $unamb_scale
        scale ambi $ambig_scale
        scale hbon $hbond_scale
        scale symm $symm_scale
        scale contact $cont_scale
        scale surface $surf_scale
      end

      evaluate ($nrdc=1)
      while ($nrdc <= $data.numrdc) loop rdc
        evaluate ($vea_bor_scale_$nrdc = min($Data.ini_bor_hot_$nrdc,$Data.fin_bor_cool3_$nrdc))
        evaluate ($vea_cen_scale_$nrdc = min($Data.ini_cen_hot_$nrdc,$Data.fin_cen_cool3_$nrdc))
        evaluate ($cln = "rd"+encode($nrdc) )
        evaluate ($san_scale_$nrdc = min($Data.rdc_hot_$nrdc,$Data.rdc_cool3_$nrdc))
        if ($Data.flags.vean eq true) then
          vean class $cln force 0.0 0.0 end
        end if
        if ($Data.flags.sani eq true) then
          sani class $cln force 0.0 end
        end if
        if ($Data.flags.xrdc eq true) then
          xrdc class $cln force 0.0 end
        end if
        evaluate ($nrdc = $nrdc + 1)
      end loop rdc

      evaluate ($ndani=1)
      while ($ndani <= $data.numdani) loop dani
       evaluate ($dan_scale_$ndani = min($Data.dan_hot_$ndani,$Data.dan_cool3_$ndani))
       if ($Data.flags.dani eq true) then
          evaluate ($cln = "da"+encode($ndani) )
          dani class $cln force 0.0 end
        end if
        evaluate ($ndani = $ndani + 1)
      end loop dani

      if ($Data.flags.xpcs eq true) then
        evaluate ($npcs=1)
        while ($npcs <= $data.numpcs) loop pcs
          evaluate ($pcs_scale_$npcs = min($Data.pcs_hot_$npcs,$Data.pcs_cool3_$npcs))
          evaluate ($cln = "pc"+encode($npcs) )
          xpcs class $cln force 0.0 end
          evaluate ($npcs= $npcs + 1)
        end loop pcs
      end if

      evaluate ($kinter = $SaProtocol.inter_rigid)
      @RUN:scale_inter_mini.cns


      ! a few rounds of rotational rigid body minimization for each independent chain
      evaluate ($imini = 0)
      while ($imini le 4) loop rigmin

        if ($imini >= 1) then
          evaluate ($paramin = false)
          evaluate ($nrdc=1)
          while ($nrdc <= $data.numrdc) loop rdc
            evaluate ($vea_bor_scale_$nrdc = min($Data.ini_bor_hot_$nrdc,$Data.fin_bor_cool3_$nrdc))
            evaluate ($vea_cen_scale_$nrdc = min($Data.ini_cen_hot_$nrdc,$Data.fin_cen_cool3_$nrdc))
            evaluate ($san_scale_$nrdc = min($Data.rdc_hot_$nrdc,$Data.rdc_cool3_$nrdc))
            evaluate ($cln = "rd"+encode($nrdc) )
            if ($Data.flags.vean eq true) then
              vean class $cln force $vea_bor_scale_$nrdc $vea_cen_scale_$nrdc end
              evaluate ($vea_bor_scale_$nrdc = min(($vea_bor_scale_$nrdc * 2),$Data.fin_bor_cool3_$nrdc))
              evaluate ($vea_cen_scale_$nrdc = min(($vea_cen_scale_$nrdc * 2),$Data.fin_cen_cool3_$nrdc))
            end if
            if ($Data.flags.sani eq true) then
              sani class $cln force $san_scale_$nrdc end
              evaluate ($san_scale_$nrdc = min($san_scale_$nrdc * 2,$Data.rdc_cool3_$nrdc))
            end if
            if ($Data.flags.xrdc eq true) then
              xrdc class $cln force $san_scale_$nrdc end
              evaluate ($san_scale_$nrdc = min($san_scale_$nrdc * 2,$Data.rdc_cool3_$nrdc))
              evaluate ($paramin = true)
            end if
            evaluate ($nrdc = $nrdc + 1)
          end loop rdc

          if ($Data.flags.sani eq true) then
            if ($rantens eq true) then
              @RUN:mini_tensor.cns
            end if
          end if

          if ($Data.flags.xpcs eq true) then
            evaluate ($npcs=1)
            while ($npcs <= $data.numpcs) loop pcs
              evaluate ($cln = "pc"+encode($npcs) )
              xpcs class $cln force $pcs_scale_$npcs end
              evaluate ($pcs_scale_$npcs = min($pcs_scale_$npcs * 2,$Data.pcs_cool3_$npcs))
              evaluate ($npcs= $npcs + 1)
            end loop pcs
          end if

          if ($paramin eq TRUE) then
            if ($rantens_para eq true) then
              @RUN:mini_tensor_para.cns
            end if
          end if

          if ($Data.flags.dani eq true) then
            evaluate ($ndani=1)
            while ($ndani <= $data.numdani) loop dani
              evaluate ($cln = "da"+encode($ndani) )
              dani class $cln force $dan_scale_$ndani end
              evaluate ($dan_scale_$ndani = min($dan_scale_$ndani * 2,$Data.dan_cool3_$ndani))
              evaluate ($ndani = $ndani + 1)
            end loop dani
            if ($rantens_dani eq true) then
              @RUN:mini_tensor_dani.cns
            end if
          end if

        end if

        evaluate ($imini = $imini + 1)
        eval ($ministeps = 500 * nint ($data.ncomponents/6 + 1))
        if ($SaProtocol.randorien eq true) then
          flag excl vdw elec coll zhar end
        end if
        eval ($nchain1 = 0)
        while ($nchain1 < $data.ncomponents) loop nloop1
          eval($nchain1 = $nchain1 + 1)
          if ($Toppar.fix_origin_$nchain1 eq false) then
            fix sele=(not all) end
            fix sele=( not (segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name OO) end
            minimize rigid
              group (segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1 and not name MAP)
              translation=false
              nstep $ministeps
              drop 10.0
              tole 0.1
              nprint 10
            end
          end if
        end loop nloop1
        fix sele=(not all) end

        flag include vdw end
        if ($Data.flags.elec0 eq true) then
          flag include elec end
        end if

        evaluate ($unamb_scale = min(($unamb_scale * 2),$Data.unamb_cool3))
        evaluate ($ambig_scale = min(($ambig_scale * 2),$Data.amb_cool3))
        evaluate ($hbond_scale = min(($hbond_scale * 2),$Data.hbond_cool3))
        evaluate ($symm_scale = min(($symm_scale * 2),$Data.ksym))

        noe
          scale dist $unamb_scale
          scale ambi $ambig_scale
          scale hbon $hbond_scale
          scale symm $symm_scale
          if ($data.flags.centroids = true) then
              scale centroid $data.centroids.kscale end
          end if
        end

      end loop rigmin

      evaluate ($unamb_scale_store = $unamb_scale)
      evaluate ($ambig_scale_store = $ambig_scale)
      evaluate ($hbond_scale_store = $hbond_scale)
      evaluate ($symm_scale_store = $symm_scale)

      flag include vdw end
      if ($Data.flags.elec0 eq true) then
        flag include elec end
      end if

      if ($SaProtocol.rigidtrans eq true) then

        if ($data.waterdock eq true) then
         if ($data.solvate_method ne "db") then
          inline @RUN:waterdock_remove-water.cns
         else
          inline @RUN:db0.cns
         end if
        end if

        evaluate ($cont_scale = $Data.kcont)
        evaluate ($surf_scale = $Data.ksurf)
        noe
          scale contact $cont_scale
          scale surface $surf_scale
        end
        fix sele=(name OO and not resn XAN) end
        minimize rigid
          eval ($nchain1 = 0)
          while ($nchain1 < $data.ncomponents) loop nloop1
            eval($nchain1 = $nchain1 + 1)
            if ($Toppar.fix_origin_$nchain1 eq false) then
              group (segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1 and not name MAP)
            end if
            translation=false
          end loop nloop1
          nstep 1000
          nprint 10
        end

        if ($data.solvate_method eq "db") then
          inline @RUN:db00.cns
        end if

        energy end

        if ($Data.flags.rg eq true) then
          flag include coll end
        end if

        if ($Data.flags.zres eq true) then
          flag incl zhar end
        end if

        fix sele=(name OO and not resn XAN) end
        eval ($ministeps = $SaProtocol.emstepstrans)
        minimize rigid
          eval ($nchain1 = 0)
          while ($nchain1 < $data.ncomponents) loop nloop1
            eval($nchain1 = $nchain1 + 1)
            if ($Toppar.fix_origin_$nchain1 eq false) then
              group (segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1 and not name MAP)
            end if
            translation=true
          end loop nloop1
          nstep $ministeps
          nprint 10
        end

        energy end

        if ($data.waterdock eq true) then
          if ($data.solvate_method eq "db") then
            display MINIMIZATION ENERGY BEFORE: $grad $ener $vdw $elec
            minimize rigid
              eval ($nchain1 = 0)
              while ($nchain1 < $data.ncomponents) loop nloop1
                eval($nchain1 = $nchain1 + 1)
                if ($Toppar.fix_origin_$nchain1 eq false) then
                  group (segid $Toppar.prot_segid_$nchain1 and not (resn WAT or resn HOH or resn TIP* or name MAP))
                end if
                translation=true
              end loop nloop1
              for $id in id ((resn WAT or resn HOH or resn TIP*) and name OH2 and (attr store5 ne 1)) loop miniwater
                group (byres(id $id))
              end loop miniwater
              translation=$data.transwater
              nstep $ministeps
              nprint 100
            end
            display MINIMIZATION ENERGY AFTER: $grad $ener $vdw $elec
            inline @RUN:db1.cns
         end if
         inline @RUN:waterdock_mini.cns
        end if

        fix sele=(name OO and not resn XAN) end
        minimize rigid
          eval ($nchain1 = 0)
          while ($nchain1 < $data.ncomponents) loop nloop1
            eval($nchain1 = $nchain1 + 1)
            if ($Toppar.fix_origin_$nchain1 eq false) then
              group (segid $Toppar.prot_segid_$nchain1 and not (resn WAT or resn HOH or resn TIP* or name MAP))
            end if
            translation=true
          end loop nloop1
          for $id in id (segid WA* and (resn WAT or resn HOH or resn TIP*) and name OH2 and (attr store5 ne 1)) loop miniwater
            group (byres(id $id))
          end loop miniwater
          translation=true
          nstep $ministeps
          nprint 10
        end
        energy end

        if ($data.waterdock eq true) then
          inline @RUN:waterdock_mini.cns
        end if

        fix sele=(not all) end

        if ($anisotropy eq true) then
          fix sele=(not all) end
          fix sele=(name OO and not resn XAN) end
          minimize rigid
            for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani
              group (byres(id $id))
              translation=false
            end loop miniani
            translation=false
            nstep 100
            drop 10.0
            nprint 10
          end
          minimize rigid
            eval ($nchain1 = 0)
            while ($nchain1 < $data.ncomponents) loop nloop1
              eval($nchain1 = $nchain1 + 1)
              if ($Toppar.fix_origin_$nchain1 eq false) then
                group (segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1 and not name MAP)
              end if
              translation=true
            end loop nloop1
            for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani
              group (byres(id $id))
              translation=false
            end loop miniani
            translation=true
            nstep $ministeps
            nprint 10
          end
        end if

        fix sele=(not all) end

      end if ! ($Saprotocol.rigidtrans eq true)

      ! centroids based energy should not be part of the $NOE energy
      if ($data.flags.centroids = true) then
          noe scale centroid 0 end
      end if

      if ($data.flags.em = true) then
          ! determine the best orientation of the complex in the density
          @RUN:em_orien_search.cns
      end if

      inline @RUN:bestener.cns

      if ($saprotocol.rotate180_it0 eq true) then
          eval($nchain1 = 0)
          while ($nchain1 < $data.ncomponents) loop nloop4
            eval($nchain1 = $nchain1 + 1)
            if ($Toppar.shape_$nchain1 eq false) then
              eval($nchain2 = $nchain1 )
              while ($nchain2 < $data.ncomponents) loop nloop3
                eval($nchain2 = $nchain2 + 1)
                if ($Toppar.shape_$nchain2 eq false) then
                  @RUN:rotation180.cns
                  if ($data.flags.em = true) then
                      @RUN:em_orien_search.cns
                  end if
                  inline @RUN:bestener.cns
                end if
              end loop nloop3
            end if
          end loop nloop4
      end if

    end loop trials

  else ! if ($Saprotocol.rigidmini = False)

    evaluate ($kinter = $SaProtocol.inter_rigid)
    @RUN:scale_inter_only.cns

    if ($Data.flags.sani eq true) then
      evaluate ($nrdc=1)
      while ($nrdc <= $data.numrdc) loop rdc
        evaluate ($cln = "rd"+encode($nrdc) )
        sani class $cln force $Data.rdc_hot_$nrdc end
        evaluate ($nrdc = $nrdc + 1)
      end loop rdc
      if ($rantens eq true) then
        @RUN:mini_tensor.cns
      end if
    end if

    evaluate ($paramin = false)
    if ($Data.flags.xrdc eq true) then
      evaluate ($nrdc=1)
      while ($nrdc <= $data.numrdc) loop rdc
        evaluate ($cln = "rd"+encode($nrdc) )
        xrdc class $cln force $Data.rdc_hot_$nrdc end
        evaluate ($nrdc = $nrdc + 1)
      end loop rdc
      evaluate ($paramin = true)
    end if

    if ($Data.flags.xpcs eq true) then
      evaluate ($npcs=1)
      while ($npcs <= $data.numpcs) loop pcs
        evaluate ($cln = "pc"+encode($npcs) )
        xpcs class $cln force $Data.pcs_hot_$npcs end
        evaluate ($paramin = true)
        evaluate ($npcs= $npcs + 1)
      end loop pcs
    end if

    if ($paramin eq TRUE) then
      if ($rantens_para eq true) then
        @RUN:mini_tensor_para.cns
      end if
    end if

    if ($Data.flags.dani eq true) then
      evaluate ($ndani=1)
      while ($ndani <= $data.numdani) loop dani
        evaluate ($cln = "da"+encode($ndani) )
        dani class $cln force $Data.dan_hot_$ndani end
        evaluate ($ndani = $ndani + 1)
      end loop dani
      if ($rantens_dani eq true) then
        @RUN:mini_tensor_dani.cns
      end if
    end if

    do (refx=x) (all)
    do (refy=y) (all)
    do (refz=z) (all)

    ! the centroid based restraints should not be included in the energy calculation
    if ($data.flags.centroids eq true) then
        noe scale centroid 0 end
    end if

    energy end
    evaluate ($bestair = $noe)

  end if ! ($Saprotocol.rigidmini = true)


{* ===================== calculate complex internal energy *}
  evaluate ($kinter = 1.0)
  @RUN:scale_intra_only.cns

  flag include bond angle dihe impr vdw end

  evaluate ($elec = 0.0)
  evaluate ($eintfree = 0.0)
  if ($Data.flags.elec0 eq true) then
    flag include elec end
  end if

  energy end

  evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec)
  evaluate ($eintfree = $eintcplx)
  {* at this stage the two are similar since rigid-body EM only *}

{* =========================== write out structure after rigid body refinement *}

  !bestener.cns: for waterdock, store3 contains store5 from lowest energy structure
  do (x = refx) (not store3)
  do (y = refy) (not store3)
  do (z = refz) (not store3)
  if ($data.waterdock eq true) then
    if ($data.solvate_method eq "restraints") then
      noe reset end
!      @RUN:read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count)
      @RUN:read_noes.cns
    end if
  end if

  evaluate ($esym = 0.0)
  evaluate ($ncs = 0.0)
  evaluate ($zhar = 0.0)
  evaluate ($rms_test_noe = 0.0)
  evaluate ($violations_test_noe = 0)
  if ($Data.flags.sym eq true) then
    noe reset nres= 2000000 end
    @RUN:symmultimer.cns
    noe
      scale symm $Data.ksym
    end
    energy end
    evaluate ($esym = $noe)
    if ($Data.noecv eq true) then
      display Print out of cross-validated violations and rms not
      display possible in combination with symmetry restraints
      display CV values set therefore to 0
    end if
    noe reset end
    set message=normal echo=on end
    !read again the NOE data, needed to remove the symmetry restraints
!    @@RUN:read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count)
    @@RUN:read_noes.cns
    if ( $log_level = "verbose" ) then
       set message=normal echo=on end
    else
       set message=off echo=off end
    end if
  else
    if ($Data.noecv eq true) then
      set message=on echo=on end
      noe cv $ncvbest ? end
    end if
    if ( $log_level = "verbose" ) then
      set message=normal echo=on end
    else
      set message=off echo=off end
    end if
    print threshold=0.3 noe
    evaluate ($rms_noe=$result)
    evaluate ($violations_noe=$violations)
    if ($Data.noecv eq true) then
      evaluate ($rms_test_noe=$test_rms)
      evaluate ($violations_test_noe=$test_violations)
    end if
  end if

  evaluate ($unamb_scale = $Data.unamb_cool3)
  evaluate ($ambig_scale = $Data.amb_cool3)
  evaluate ($hbond_scale = $Data.hbond_cool3)
  if ($data.solvate_method eq "restraints") then
    evaluate ($amwa_scale = $data.water_restraint_scale)
  end if

  noe
    scale dist $unamb_scale
    scale ambi $ambig_scale
    scale hbon 0.0
    scale cont 0.0
    if ($data.solvate_method eq "restraints") then
     scale amwa $amwa_scale
    end if
  end

{* ===================== calculate final energies and write structure *}
  flag incl bond angl impr noe end
  flag exclude xref end
  if ($Data.flags.sani eq true) then
    flag incl sani end
  end if
  if ($Data.flags.xrdc eq true) then
    flag incl xrdc end
  end if
  if ($Data.flags.xpcs eq true) then
    flag incl xpcs end
  end if
  if ($Data.flags.dani eq true) then
    flag incl dani end
  end if
  if ($Data.flags.vean eq true) then
    flag incl vean end
  end if

  if ($Data.flags.rg eq true ) then
    collapse force $Data.krg_cool3 end
  end if

  if ($Data.flags.zres eq true) then
    flag incl zhar end
  end if

  if ($data.ncomponents > 1) then
    evaluate ($kinter = 1.0)
    @RUN:scale_inter_final.cns
  else
    @RUN:scale_intra_only.cns
  end if
  energy end
  evaluate ($cdih = 0.0)
  evaluate ($etot = $ener - $noe)
  evaluate ($noe = $bestair)
  evaluate ($etot = $etot + $noe)

  evaluate ($Data.flags.dihed = false)
!  evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".pdb0")
  inline @RUN:print_coorheader.cns

  if ($reorient eq true) then
    coor sele=(segid $Toppar.prot_segid_1) orient end
  end if

  write coordinates sele=(not resn DUM) output=$output_pdb_filename end

 set message=normal echo=on end
 display OUTPUT: $output_pdb_filename

! no identation, this marks the end of the recipe
stop

